/* autogenerated by Processing revision 1290 on 2025-07-29 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.Minim;
import ddf.minim.AudioPlayer;
import java.util.Map;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;
import java.util.Iterator;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class roguelike extends PApplet {

 //<>// //<>// //<>// //<>//








Minim minim;
AudioPlayer main_music;
AudioPlayer soda_1;
AudioPlayer soda_2;
AudioPlayer food_1;
AudioPlayer food_2;
AudioPlayer footstep_1;
AudioPlayer footstep_2;
AudioPlayer chop_1;
AudioPlayer chop_2;
AudioPlayer enemy_1_attack;
AudioPlayer enemy_2_attack;
AudioPlayer die;

enum Game_State {PAUSE, ON, NEXT_LEVEL, DIE};

PImage[][] floor;
PImage[][] wall;
PImage     exit;
int tile_size   = 64;
int tile_number = 10;
int enemy_number = 1;
int destructible_number = 10;
int edible_number = 3;

enum  Objects {FLOOR, WALL, EDIBLE, DESTRUCTIBLE, ENEMY, HERO, _EXIT};

Objects[][] game_board;

List<Edible> edibles;
List<Destructible> destructibles;
List<Character> enemies;

Character hero;

Game_State game_state;

PFont font;

int level = 1;
int score = 100;



public void setup(){
  windowTitle("RogueLike");
  /* size commented out by preprocessor */;
  
  floor = new PImage[tile_number][tile_number];
  wall  = new PImage[tile_number][tile_number];
  exit  = loadImage("../images/others/exit.png");
  font  = createFont("../font/PressStart2P-Regular.ttf", 32);
  
  textFont(font);
  textSize(18);

  exit.resize(tile_size, tile_size);
  
  minim = new Minim(this);
  
  main_music     = minim.loadFile("../music/scavengers_music.mp3");
  soda_1         = minim.loadFile("../music/scavengers_soda1.mp3");
  soda_2         = minim.loadFile("../music/scavengers_soda2.mp3");
  chop_1         = minim.loadFile("../music/scavengers_chop1.mp3");
  chop_2         = minim.loadFile("../music/scavengers_chop2.mp3");
  footstep_1     = minim.loadFile("../music/scavengers_footstep1.mp3");
  footstep_2     = minim.loadFile("../music/scavengers_footstep2.mp3");
  enemy_1_attack = minim.loadFile("../music/scavengers_enemy1.mp3");
  enemy_2_attack = minim.loadFile("../music/scavengers_enemy2.mp3");
  food_1         = minim.loadFile("../music/scavengers_fruit1.mp3");
  food_2         = minim.loadFile("../music/scavengers_fruit2.mp3");
  die            = minim.loadFile("../music/scavengers_die.mp3");
  
  game_state = Game_State.NEXT_LEVEL;
  main_music.loop();
  set_game();
}

public void set_game(){
  game_board = new Objects[tile_number][tile_number];
  
  set_game_board();
  
  set_floor();
  
  set_wall();
  
  game_board[1][8] = Objects._EXIT;
  
  set_hero();
  
  set_destructibles();
  
  set_edibles();
  
  set_enemies();
  
  if (level % 5 == 0){
    enemy_number++;
    edible_number++;
  }
  
  //print_board();
  //println("\n");
}

public void draw(){ 
  
  draw_level();
  if (game_state == Game_State.NEXT_LEVEL){
    noLoop();
    background(0);
    text("Day: " + level, 220, 280);
    text("Score: " + score, 220, 320);
    
    set_game();
    
    level_pause(2000, Game_State.ON, true);
  }
  
  else if (game_state == Game_State.DIE){
    main_music.pause();
    die.play();
    background(0);
    text("After " + level + " days you died.", 180, 320);
  }
  
}

public void draw_level(){
  draw_floor();
  draw_wall();
  image(exit, 8 * tile_size, 1 * tile_size);
  draw_destructibles();
  draw_edibles();
  draw_enemies();
  
  if (score <= 0){
    game_state = Game_State.DIE;
    return;
  }
  
  text("Score: " + score, 220, 620);
  hero.play_animation();
  //println(frameRate);
}

public boolean contains_destructible(int x, int y){
  for (Destructible temp : destructibles){
    if (temp.x == x && temp.y == y)
      return true;
  }
  
  return false;
}

public boolean contains_enemy(int x, int y){
  for (Character temp : enemies){
    if (temp.x == x && temp.y == y)
      return true;
  }
  
  return false;
}

public boolean contains_edible(int x, int y){
  for (Edible temp : edibles){
    if (temp.x == x && temp.y == y)
      return true;
  }
  
  return false;
}

public String closest_direction(int x, int y){
  
  if (x == hero.x){
    if (y < hero.y)
      return "down";
    if (y > hero.y)
      return "up";
  }
  
  if (y == hero.y){
    if (x < hero.x)
      return "right";
    if (x > hero.x)
      return "left";
  }
  
  int grid_x = y;
  int grid_y = x;
  int hero_x = hero.y;
  int hero_y = hero.x;
  
  int d_x = Math.abs(grid_x - hero_x);
  int d_y = Math.abs(grid_y - hero_y);
  
  if (grid_x > hero.y && grid_y > hero_y){
    if (d_x < d_y)
      return "up";
    else if (d_y < d_x)
      return "left";
    else{
      int k = PApplet.parseInt(random(0, 2));
      return k == 1 ? "left" : "up";
    }
  }
  
  if (grid_x > hero_x && grid_y < hero_y){
    if (d_x < d_y)
      return "up";
    else if (d_y < d_x)
      return "right";
    else{
      int k = PApplet.parseInt(random(0, 2));
      return k == 1 ? "right" : "up";
    }
  }
  
  if (grid_x < hero_x && grid_y < hero_y){
    if (d_x < d_y)
      return "down";
    else if (d_y < d_x)
      return "right";
    else{
      int k = PApplet.parseInt(random(0, 2));
      return k == 1 ? "right" : "down";
    }
  }
  
  if (grid_x < hero_x && grid_y > hero_y){
    if (d_x < d_y)
      return "down";
    else if (d_y < d_x)
      return "left";
    else{
      int k = PApplet.parseInt(random(0, 2));
      return k == 1 ? "left" : "down";
    }
  }
  
  return "no";
}

public void decrease_destructible(int x, int y){
  for (Destructible temp : destructibles){
    if (x == temp.x && y == temp.y){
      temp.health--;
      
      if (temp.health == 2)temp.current = temp.damaged;
      else if (temp.health == 0){destructibles.remove(temp); game_board[y][x] = Objects.FLOOR;}
      
      return;
    }
  }
}

public void draw_destructibles(){
  for (Destructible temp : destructibles){
    image(temp.current, temp.x * tile_size, temp.y * tile_size);
  }
}

public void draw_edibles(){
  for (Edible temp : edibles){
    image(temp.img, temp.x * tile_size, temp.y * tile_size);
  }
}

public void draw_enemies(){
  for (Character temp : enemies){
    temp.play_animation();
  }
}

public void draw_floor(){
  for (int i = 0; i < floor.length; i++){
    for (int j = 0; j < floor[0].length; j++){
      image(floor[i][j], i * tile_size, j * tile_size);
    }
  }
}

public void draw_wall(){
  for (int i = 0; i < wall.length; i++){
    for (int j = 0; j < wall[0].length; j++){
      if (wall[i][j] != null){
        image(wall[i][j], i * tile_size, j * tile_size);
      }
    }
  }
}

public void eat_edible(int x, int y){
  Iterator<Edible> iter = edibles.iterator();
  
  while (iter.hasNext()){
    Edible temp = iter.next();
    if (temp.x == x && temp.y == y){
      iter.remove();
      
      int k = PApplet.parseInt(random(0, 2));
      
      if (temp.type.equals("soda")){
        if (k == 0){soda_1.play(); soda_1.rewind();}
        else{soda_2.play(); soda_2.rewind();}
        score += 10;
      }else{
        if (k == 0){food_1.play(); food_1.rewind();}
        else{food_2.play(); food_2.rewind();}
        score += 15;
      }
    }
  }
}

public boolean is_in_frame(int x, int y){
  return x == 0 || x == 9 || y == 0 || y == 9;
}

public void keyReleased(){
  if (game_state == Game_State.ON){
    if (keyCode == RIGHT)
      hero.move("right");
    if (keyCode == UP)
      hero.move("up");
    if (keyCode == LEFT)
      hero.move("left");
    if (keyCode == DOWN)
      hero.move("down");
  }
}

public void animation_pause(Character chr){
  Timer timer = new Timer();
  
  timer.schedule(new TimerTask(){
    public void run(){
      chr.setAnimation("idle", 100);
    }
  }, 300);
}

public void move_pause(){
  Timer timer = new Timer();
  
  timer.schedule(new TimerTask(){
    public void run(){
      game_state = Game_State.ON;
    }
  }, 500);
}

public void level_pause(int time, Game_State state, boolean loop_flag){
  Timer timer = new Timer();
  
  timer.schedule(new TimerTask(){
    public void run(){
      if (loop_flag)
        loop();
      game_state = state;
    }
  }, time);
}

public void set_destructibles(){
  destructibles = new ArrayList<Destructible>();
  
  for (int i = 0; i < destructible_number; i++){
    int x = 0;
    int y = 0;
    
    while ((x == 8 && y == 1) || //coordinations for exit
           (is_in_frame(x, y))||
           (x == hero.x && y == hero.y) ||
           (contains_destructible(x, y))){
             x = PApplet.parseInt(random(1, 9));
             y = PApplet.parseInt(random(1, 9));
    }
    
    PImage[] temp = new PImage[2];
    
    int k = PApplet.parseInt(random(1, 8));
    
    temp[0] = loadImage("../images/destructibles/new_" + k + ".png");
    temp[1] = loadImage("../images/destructibles/damaged_" + k + ".png");
    temp[0].resize(tile_size, tile_size);
    temp[1].resize(tile_size, tile_size);
    
    
    destructibles.add(new Destructible(x, y, temp[0], temp[1]));
    game_board[y][x] = Objects.DESTRUCTIBLE;
  }
}

public void set_edibles(){
  edibles = new ArrayList<Edible>();
  
  for (int i = 0; i < edible_number; i++){
    int x = 0;
    int y = 0;
    
    while ((x == 8 && y == 1) || //coordination of exit
            is_in_frame(x, y) || 
            (x == hero.x && y == hero.y) || 
            (contains_destructible(x, y)) ||
            (contains_edible(x, y))){
      x = PApplet.parseInt(random(1, 9));
      y = PApplet.parseInt(random(1, 9));
    }
    
    int k = PApplet.parseInt(random(0, 2));
    String type = k == 0 ? "soda" : "food";
    
    String image_path = "../images/others/" + type + ".png";
    
    PImage temp = loadImage(image_path);
    temp.resize(tile_size, tile_size);
    
    edibles.add(new Edible(x, y, type, temp));
    
    game_board[y][x] = Objects.EDIBLE;
  }
}

public void set_enemies(){
  enemies = new ArrayList<Character>();
  
  for (int i = 0; i < enemy_number; i++){
    int x = PApplet.parseInt(random(1, 9));
    int y = PApplet.parseInt(random(1, 9));
    
    while ((x == 8 && y == 1)  ||
           (is_in_frame(x, y)) ||
           (x == hero.x && y == hero.y) ||
           (contains_destructible(x, y)) ||
           (contains_edible(x, y)) ||
           (contains_enemy(x, y))){
             x = PApplet.parseInt(random(1, 9));
             y = PApplet.parseInt(random(1, 9));
    }
    
    PImage[] idle_animation   = new PImage[6];
    PImage[] attack_animation = new PImage[2]; 
    
    int k = PApplet.parseInt(random(1,3));
    
    String path = "../images/enemy_" + k + "/" ;
    
    for (int j = 0; j < idle_animation.length; j++){
      PImage temp = loadImage(path + "idle_" + (j + 1) + ".png");
      temp.resize(tile_size, tile_size);
      idle_animation[j] = temp;
    }
    
    for (int j = 0; j < attack_animation.length; j++){
      PImage temp = loadImage(path + "attack_" + (j + 1) + ".png");
      temp.resize(tile_size, tile_size);
      attack_animation[j] = temp;
    }
    
    Map<String, PImage[]> animations = new HashMap();
  
    animations.put("idle", idle_animation);
    animations.put("attack", attack_animation);
    
    AnimationPlayer animator = new AnimationPlayer(animations);
    
    Character enemy = new Character(animator, x, y, "enemy" + k);
    enemy.setAnimation("idle", 100);
    enemies.add(enemy);
    game_board[y][x] = Objects.ENEMY;
  }
}


public void set_floor(){
  for (int i = 0; i < floor.length; i++){
    for (int j = 0; j < floor[0].length; j++){
      PImage temp = loadImage("../images/floor/" + (PApplet.parseInt(random(1, 9))) + ".png");
      temp.resize(tile_size,tile_size);
      floor[i][j] = temp;
    }
  }
}

public void set_game_board(){
  for (int i = 0; i < game_board.length; i++){
    for (int j = 0; j < game_board[0].length; j++){
      if (i == 0 || i == game_board.length - 1 || j == 0 || j == game_board[0].length - 1){
        game_board[i][j] = Objects.WALL;
      }else{
        game_board[i][j] = Objects.FLOOR;
      }
    }
  }
}

public void set_hero(){
  int x = 1;
  int y = 8;
  PImage[] idle_animation   = new PImage[6];
  PImage[] dig_animation    = new PImage[2];
  PImage[] attack_animation = new PImage[2];
  
  for (int i = 0; i < idle_animation.length; i++){
    PImage temp = loadImage("../images/hero/idle_" + (i + 1) + ".png");
    temp.resize(tile_size, tile_size);
    idle_animation[i] = temp;
  }
  
  for (int i = 0; i < dig_animation.length; i++){
    PImage temp = loadImage("../images/hero/dig_" + (i + 1) + ".png");
    temp.resize(tile_size, tile_size);
    dig_animation[i] = temp;
  }
  
  for (int i = 0; i < attack_animation.length; i++){
    PImage temp = loadImage("../images/hero/attack_" + (i + 1) + ".png");
    temp.resize(tile_size, tile_size);
    attack_animation[i] = temp;
  }
  
  Map<String, PImage[]> animations = new HashMap();
  
  animations.put("idle", idle_animation);
  animations.put("dig", dig_animation);
  animations.put("attack", attack_animation);
  
  AnimationPlayer animator = new AnimationPlayer(animations);
  
  hero = new Character(animator, x, y, "hero");
  hero.setAnimation("idle", 100);
  game_board[y][x] = Objects.HERO;
}

public void set_wall(){
  for (int i = 0; i < wall.length; i++){
    for (int j = 0; j < wall[0].length; j++){
      if (i == 0 || i == wall.length - 1 || j == 0 || j == wall[0].length - 1){
        PImage temp = loadImage("../images/walls/" + (PApplet.parseInt(random(1, 5))) + ".png");
        temp.resize(tile_size,tile_size);
        wall[i][j] = temp;    
      }
    }
  }
}



class Character{
  AnimationPlayer animator;
  String type;
  int x;
  int y;
  
  Character(AnimationPlayer animator, int x, int y, String type){
    this.x = x;
    this.y = y;
    this.animator = animator;
    this.type = type;
  }
  
  public void play_animation(){
    this.animator.animate(x, y);
  }
  
  public void setAnimation(String animation, int speed){
    animator.current_animation =  animator.animations.get(animation);
    animator.speed = speed;
  }
  
  public void move(String dir){
    if (dir.equals("no"))
      return;
      
    //println(type + ": " + x + "," +  y + "," + dir);
    
    if (dir.equals("right")){
      if (game_board[y][x + 1] != Objects.WALL){
        if (game_board[y][x + 1] == Objects.EDIBLE && type.equals("hero")){
          game_board[y][x]     = Objects.FLOOR;
          game_board[y][x + 1] = Objects.HERO;
          eat_edible(x + 1, y);
          x++;
        }else if (game_board[y][x + 1] == Objects.FLOOR){
          game_board[y][x]     = Objects.FLOOR;
          game_board[y][x + 1] = type.equals("hero") ? Objects.HERO : Objects.ENEMY;
          x++;
          
          if (type.equals("hero")){
            int k = PApplet.parseInt(random(0, 2));
            if (k == 0){footstep_1.play(); footstep_1.rewind();}
            else{footstep_2.play(); footstep_2.rewind();}
          }
        }else if (game_board[y][x + 1] == Objects.DESTRUCTIBLE && type.equals("hero")){
          setAnimation("dig", 200); 
          
          int k = PApplet.parseInt(random(0, 2));
          if (k == 0){chop_1.play(); chop_1.rewind();}
          else{chop_2.play(); chop_2.rewind();}          
          
          decrease_destructible(x + 1, y); 
          animation_pause(this);
        }else if (game_board[y][x + 1] == Objects._EXIT && type.equals("hero")){
          game_board[y][x] = Objects.FLOOR;
          x++;
        }else if (game_board[y][x + 1] == Objects.HERO){
          setAnimation("attack", 200);
          if (type.equals("enemy1")){enemy_1_attack.play(); enemy_1_attack.rewind();}
          else{enemy_2_attack.play(); enemy_2_attack.rewind();}
          hero.setAnimation("attack", 200);
          animation_pause(hero);
          animation_pause(this);
          score -= 10;
        }
        
        if (type.equals("hero"))score--;
      }
    }else if (dir.equals("up")){
        if (game_board[y - 1][x] != Objects.WALL){
          if (game_board[y - 1][x] == Objects.EDIBLE && type.equals("hero")){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y - 1][x] = Objects.HERO;
            eat_edible(x, y - 1);
            y--;           
          }else if (game_board[y - 1][x] == Objects.FLOOR){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y - 1][x] = type.equals("hero") ? Objects.HERO : Objects.ENEMY;
            y--;
            
            if (type.equals("hero")){
              int k = PApplet.parseInt(random(0, 2));
              if (k == 0){footstep_1.play(); footstep_1.rewind();}
              else{footstep_2.play(); footstep_2.rewind();}
            }
          }else if (game_board[y - 1][x] == Objects.DESTRUCTIBLE && type.equals("hero")){
            setAnimation("dig", 200);
            int k = PApplet.parseInt(random(0, 2));
            if (k == 0){chop_1.play(); chop_1.rewind();}
            else{chop_2.play(); chop_2.rewind();}             
            decrease_destructible(x, y - 1);
            animation_pause(this);
          }else if (game_board[y - 1][x] == Objects._EXIT && type.equals("hero")){
            game_board[y][x] = Objects.FLOOR;
            y--;
          }else if (game_board[y - 1][x] == Objects.HERO){
            setAnimation("attack", 200);
            if (type.equals("enemy1")){enemy_1_attack.play(); enemy_1_attack.rewind();}
            else{enemy_2_attack.play(); enemy_2_attack.rewind();}
            hero.setAnimation("attack", 200);
            animation_pause(hero);
            animation_pause(this);
            score -= 10;
          }
          if (type.equals("hero"))score--;
        }
      }else if (dir.equals("left")){
        if (game_board[y][x - 1] != Objects.WALL){
          if (game_board[y][x - 1] == Objects.EDIBLE && type.equals("hero")){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y][x - 1] = Objects.HERO;
            eat_edible(x - 1, y);
            x--;
          }else if (game_board[y][x - 1] == Objects.FLOOR){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y][x - 1] = type.equals("hero") ? Objects.HERO : Objects.ENEMY;
            x--;

            if (type.equals("hero")){
              int k = PApplet.parseInt(random(0, 2));
              if (k == 0){footstep_1.play(); footstep_1.rewind();}
              else{footstep_2.play(); footstep_2.rewind();}
            }
          }else if (game_board[y][x - 1] == Objects.DESTRUCTIBLE && type.equals("hero")){
            setAnimation("dig", 200);
            int k = PApplet.parseInt(random(0, 2));
            if (k == 0){chop_1.play(); chop_1.rewind();}
            else{chop_2.play(); chop_2.rewind();}             
            decrease_destructible(x - 1, y);
            animation_pause(this);
          }else if (game_board[y][x - 1] == Objects.HERO){
            setAnimation("attack", 200);
            if (type.equals("enemy1")){enemy_1_attack.play(); enemy_1_attack.rewind();}
            else{enemy_2_attack.play(); enemy_2_attack.rewind();}
            hero.setAnimation("attack", 200);
            animation_pause(hero);
            animation_pause(this);
            score -= 10;
          }
          if (type.equals("hero"))score--;
        }
      }else if (dir.equals("down")){
        if (game_board[y + 1][x] != Objects.WALL){
          if (game_board[y + 1][x] == Objects.EDIBLE && type.equals("hero")){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y + 1][x] = Objects.HERO;
            eat_edible(x, y + 1);
            y++;
          }else if (game_board[y + 1][x] == Objects.FLOOR){
            game_board[y][x]     = Objects.FLOOR;
            game_board[y + 1][x] = type.equals("hero") ? Objects.HERO : Objects.ENEMY;
            y++;
            
            if (type.equals("hero")){
              int k = PApplet.parseInt(random(0, 2));
              if (k == 0){footstep_1.play(); footstep_1.rewind();}
              else{footstep_2.play(); footstep_2.rewind();}
            }
          }else if (game_board[y + 1][x] == Objects.DESTRUCTIBLE && type.equals("hero")){
            setAnimation("dig", 200);
            int k = PApplet.parseInt(random(0, 2));
            if (k == 0){chop_1.play(); chop_1.rewind();}
            else{chop_2.play(); chop_2.rewind();}             
            decrease_destructible(x, y + 1);
            animation_pause(this);
          }else if (game_board[y + 1][x] == Objects.HERO){
            setAnimation("attack", 200);
            if (type.equals("enemy1")){enemy_1_attack.play(); enemy_1_attack.rewind();}
            else{enemy_2_attack.play(); enemy_2_attack.rewind();}
            hero.setAnimation("attack", 200);
            animation_pause(hero);
            animation_pause(this);
            score -= 10;
          }
          if (type.equals("hero"))score--;;
        }
      }
      
      if (game_board[y][x] == Objects._EXIT){
        game_state = Game_State.PAUSE;
        level++;
        level_pause(2000, Game_State.NEXT_LEVEL, false);
        return;
      }
      
      if (type.equals("hero")){
        game_state = Game_State.PAUSE;
        
        for (Character enemy : enemies){
          enemy.move(closest_direction(enemy.x, enemy.y));
        }
        
        move_pause();
      }
      
    /*if (type.equals("hero")){
      print_board();
      println("\n\n");
    }*/
    //println(type + ": " + x + ", " + y);
  }
}

class AnimationPlayer{
  Map<String, PImage[]> animations;
  PImage[]              current_animation;
  int speed;
  int k = 0;
  long now = millis();
  
  AnimationPlayer(Map<String, PImage[]> animations){
    this.animations = animations;
    speed = 100;
  }
  
  public void animate(int x, int y){
    if (k < current_animation.length)
      image(current_animation[k], x * tile_size, y * tile_size);
    
    if (millis() - now > speed)
      {
        k++;   
        now = millis();
      }
    
    
    
    if (k >= current_animation.length)
      k = 0;
    
  }
}


class Destructible{
  int x;
  int y;
  PImage current;
  PImage undamaged;
  PImage damaged;
  int health;
  
  Destructible(int x, int y, PImage undamaged, PImage damaged){
    this.x = x;
    this.y = y;
    
    this.current   = undamaged;
    this.damaged   = damaged;
    this.undamaged = undamaged;
    health         = 4;
  }
}

class Edible{
  int x;
  int y;
  String type;
  PImage img;
  
  public Edible(int x, int y, String type, PImage img){
    this.x = x;
    this.y = y;
    
    this.type = type;
    this.img  = img;
  }
}

public void print_board(){
  for (int i = 0; i < game_board.length; i++){
    for (int j = 0; j < game_board[0].length; j++){
      print(game_board[i][j] + " ");}
    println();}
      
}


  public void settings() { size(640, 640); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "roguelike" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
